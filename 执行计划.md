[TOC]



# MySQL执行计划解析

查看执行计划的主要几个指标

```sql
1 SQL文本 执行计划文本
2 show create table , show table status
3 show variables like '%heap%';
4 show variables like '%tmp_table_size%';
  以上3,4两个是临时表参数
  --tmp_table_size 控制内存临时表的最大值,超过限值后就往硬盘写，写的位置由变量 tmpdir 决定 
  --max_heap_table_size 用户可以创建的内存表(memory table)的大小.这个值用来计算内存表的最大行数值。
5 show variables like '%innodb_buffer_pool_size%'
6 show variables like '%join%_size%';
join_buffer_size
--联合查询操作所能使用的缓冲区大小
```



## id

执行计划的查看：

```mysql
ID列表明了该语句所在的层级
如果ID相同从上到下执行
如果ID不同则ID越大的越先执行
其作用类似于执行计划中缩进
```

```sql
mysql> desc select * from t_group\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t_group
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.01 sec)

mysql> show warnings\G;
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `employees`.`t_group`.`emp_no` AS `emp_no`,`employees`.`t_group`.`dept_no` AS `dept_no`,`employees`.`t_group`.`from_date` AS `from_date`,`employees`.`t_group`.`to_date` AS `to_date` from `employees`.`t_group`
1 row in set (0.00 sec
              
              
简单的join，ID都是1
子查询subquery 标量子查询scala subquery 会使id递增
```



## select type

### simple

```sql
不使用union或者子查询的简单查询：不包含优化器打开子查询的情况
mysql的执行计划从上到下观察
```



### primary

```shell
使用union ，子查询的query
```

### union

```powershell
使用union 除了第一个之外的select子句  select type用union；
union result是union去掉重复值的临时表
使用union all不去重，不会出现union result（针对5.7以上的版本）
```

### subquery

```
指在select和from之间的子查询，并且和外部表没有关联

注意：对于子查询来说，执行计划没错，不代表SQL能够执行。例如：标量子查询返回的结果大于一行
```



### dependent subquery

```shell
依赖于外查询的结果的查询:如标量子查询，exists

注意：在标量子查询，exists同时出现相同的表，会无法区分执行计划，可以给此表取不同的别名区分。
```



### derived

```sql
from 后面 的子查询

derived 是生成结果在内存或者临时表空间当中
如果derived的表作为驱动表时，优化的方向是减少数据量
若作为被驱动表时，产生auto_key索引 ，优化的方向是减少数据量


Variable_name: optimizer_switch
        Value: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on
--derived_merge=on 将简单的subquery打开，转化为join（从5.7开始有此参数）


注意：
以下情况不会打开子查询,不会视图合并：
1. union/union all   子查询中有union
2. group by
3. distinct
4. 聚合函数
5. limit
6. @


实验：
mysql> select count(1) from employees e straight_join (select t.* from t_group3 t) s  on s.emp_no=e.emp_no;
   +----------+
   | count(1) |
   +----------+
   |     2010 |
   +----------+
   1 row in set (23.71 sec)
   
mysql> desc select count(1) from employees e straight_join (select t.* from t_group3 t) s  on s.emp_no=e.emp_no\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: e
      partitions: NULL
            type: index
   possible_keys: PRIMARY
             key: PRIMARY
         key_len: 4
             ref: NULL
            rows: 299202
        filtered: 100.00
           Extra: Using index
   *************************** 2. row ***************************
              id: 1
     select_type: SIMPLE
           table: t
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 2010
        filtered: 10.00
           Extra: Using where; Using join buffer (Block Nested Loop)
   2 rows in set, 1 warning (0.00 sec)
   
   
   mysql> select count(1) from employees e straight_join (select t.* from t_group3 t limit 20000) s  on s.emp_no=e.emp_no;
   +----------+
   | count(1) |
   +----------+
   |     2010 |
   +----------+
   1 row in set (0.14 sec)
   
   
   mysql> desc select count(1) from employees e straight_join (select t.* from t_group3 t limit 20000) s  on s.emp_no=e.emp_no\G;
   *************************** 1. row ***************************
              id: 1
     select_type: PRIMARY
           table: e
      partitions: NULL
            type: index
   possible_keys: PRIMARY
             key: PRIMARY
         key_len: 4
             ref: NULL
            rows: 299202
        filtered: 100.00
           Extra: Using index
   *************************** 2. row ***************************
              id: 1
     select_type: PRIMARY
           table: <derived2>
      partitions: NULL
            type: ref
   possible_keys: <auto_key0>
             key: <auto_key0>
         key_len: 4
             ref: employees.e.emp_no
            rows: 10
        filtered: 100.00
           Extra: NULL
   *************************** 3. row ***************************
              id: 2
     select_type: DERIVED
           table: t
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 2010
        filtered: 100.00
           Extra: NULL
   3 rows in set, 1 warning (0.00 sec)
   
注释：
此参数on/off对SQL优化的影响:
1. on的时候，被驱动表的连接条件需要有索引
2. off的时候，被驱动表的结果集要小

优化方向：

1. 尽量减少子查询的数量
2. order by的谨慎使
```



### materialized

```SQL
子查询物化 
使用IN的时候产生 ，也产生auto_key索引
当表出现在非相关子查询中 并且需要进行物化时会出现MATERIALIZED关键词
注意：
SQL语句中注释的格式最好使用 /* */

mysql> desc select /*+ SEMIJOIN (@sub MATERIALIZATION) */ * from t_order t2 where t2.emp_no in (select /*+ QB_NAME(sub) */ t1.emp_no from dept_emp t1)\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t2
   partitions: NULL
         type: ALL
possible_keys: ix_t1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: <subquery2>
   partitions: NULL
         type: eq_ref
possible_keys: <auto_key>
          key: <auto_key>
      key_len: 4
          ref: employees.t2.emp_no
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: 2
  select_type: MATERIALIZED
        table: t1
   partitions: NULL
         type: index
possible_keys: PRIMARY,emp_no
          key: emp_no
      key_len: 4
          ref: NULL
         rows: 331143
     filtered: 100.00
        Extra: Using index
3 rows in set, 1 warning (0.00 sec)

加上hint的执行计划和不加的执行计划的区别：
mysql> desc select * from t_order t2 where t2.emp_no in (select /*+ QB_NAME(sub) */ t1.emp_no from dept_emp t1)\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t2
   partitions: NULL
         type: ALL
possible_keys: ix_t1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ref
possible_keys: PRIMARY,emp_no
          key: emp_no
      key_len: 4
          ref: employees.t2.emp_no
         rows: 1
     filtered: 100.00
        Extra: Using index; FirstMatch(t2)
2 rows in set, 1 warning (0.00 sec)
```



## Table

访问的表,注意即使访问的是索引 这里也显示访问的表名

### null

表示不使用任何表或者使用了dual

比较特殊的有count：

```SQL
mysql> flush status;
Query OK, 0 rows affected (0.01 sec)

mysql> show profiles;
Empty set, 1 warning (0.00 sec)

mysql> desc select count(1) from employees;
+----+-------------+-----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | index | NULL          | PRIMARY | 4       | NULL | 299202 |   100.00 | Using index |
+----+-------------+-----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> show profiles;
Empty set, 1 warning (0.00 sec)

mysql> set profiling=1;
Query OK, 0 rows affected, 1 warning (0.00 sec)



mysql> desc select count(1) from employees;
+----+-------------+-----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | index | NULL          | PRIMARY | 4       | NULL | 299202 |   100.00 | Using index |
+----+-------------+-----------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> select count(1) from employees;
+----------+
| count(1) |
+----------+
|   300024 |
+----------+
1 row in set (0.54 sec)

mysql> show profiles;
+----------+------------+-------------------------------------+
| Query_ID | Duration   | Query                               |
+----------+------------+-------------------------------------+
|        1 | 0.00039100 | desc select count(1) from employees |
|        2 | 0.54533300 | select count(1) from employees      |
+----------+------------+-------------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show profile for query 2;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000045 |
| checking permissions | 0.000005 |
| Opening tables       | 0.000011 |
| init                 | 0.000010 |
| System lock          | 0.000006 |
| optimizing           | 0.000003 |
| statistics           | 0.000008 |
| preparing            | 0.000007 |
| executing            | 0.000002 |
| Sending data         | 0.545191 |
| end                  | 0.000010 |
| query end            | 0.000008 |
| closing tables       | 0.000006 |
| freeing items        | 0.000014 |
| cleaning up          | 0.000008 |
+----------------------+----------+
15 rows in set, 1 warning (0.00 sec)

mysql> show status like '%handle%';
+---------------------------------------+--------+
| Variable_name                         | Value  |
+---------------------------------------+--------+
| Handler_commit                        | 3      |
| Handler_delete                        | 0      |
| Handler_discover                      | 0      |
| Handler_external_lock                 | 8      |
| Handler_mrr_init                      | 0      |
| Handler_prepare                       | 0      |
| Handler_read_first                    | 1      |
| Handler_read_key                      | 1      |
| Handler_read_last                     | 0      |
| Handler_read_next                     | 300024 |
| Handler_read_prev                     | 0      |
| Handler_read_rnd                      | 0      |
| Handler_read_rnd_next                 | 1044   |
| Handler_rollback                      | 0      |
| Handler_savepoint                     | 0      |
| Handler_savepoint_rollback            | 0      |
| Handler_update                        | 0      |
| Handler_write                         | 528    |
| Performance_schema_file_handles_lost  | 0      |
| Performance_schema_table_handles_lost | 0      |
+---------------------------------------+--------+

| Handler_commit             | 内部提交语句数
| Handler_delete             | 请求从表中删除行的次数。
| Handler_discover           | MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。
| Handler_external_lock      | 此变量与锁定操作数量有关，主要是在表访问的开始和结束时起作用。
| Handler_mrr_init           | 服务器使用存储引擎自己实现的多范围读取的次数。
| Handler_prepare            | 用于两阶段提交操作的准备阶段的计数器。
| Handler_read_first         | 索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。
| Handler_read_key           | 根据键读一行的请求数。如果较高，说明查询和表的索引正确。
| Handler_read_last          | 根据键读最后一行的请求数。
| Handler_read_next          | 按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。
| Handler_read_prev          | 按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。
| Handler_read_rnd           | 根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用索引。
| Handler_read_rnd_next      | 在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。
| Handler_rollback           | 内部ROLLBACK语句的数量
| Handler_savepoint          | 在一个存储引擎放置一个保存点的请求数量。
| Handler_savepoint_rollback | 在一个存储引擎的要求回滚到一个保存点数目。
| Handler_update             | 请求更新表中一行的次数。 
| Handler_write              | 请求向表中插入一行的次数



mysql> set profiling=0;
Query OK, 0 rows affected, 1 warning (0.00 sec)



1. 表名或者别名
SQL书写规范：每个表必须加上别名，查询字段用别名注明归属。

2. <derived+id> <union+id>
表示临时表<>里面的数字是id列：重点关注id指向的执行计划的行。

```



## TYPE

### type的优先级

```sql
null->system->const->eq-ref->ref->fulltext->ref_or_null->index_merge->unique_subquery->index_subquery->range->index->ALL
```

### const

```sql
当使用PK或者unique key取得一条数据时

此种类型查询最多返回一行记录,由于只有一行记录,后续优化器会把它当作常量. 
基本可以认为表进行了索引唯一性扫描,并且唯一性索引只返回一行记录

show warnings 显示异常数
```

### eq_ref

```sql 
必须是join,且满足被驱动表的连接条件是PK或者UK
```

### ref

索引非唯一性扫描,对索引列使用=条件

### ref_or_null

```sql
当谓词出现索引列等于某值或为空时出现

EXPLAIN SELECT * FROM DAO_OBJECTS1 WHERE OBJECT_NAME ='DBA_TABLES' OR OBJECT_NAME is NULL ;
+----+-------------+--------------+-------------+---------------+---------------+---------+-------+------+-----------------------+
| id | select_type | table        | type        | possible_keys | key           | key_len | ref   | rows | Extra                 |
+----+-------------+--------------+-------------+---------------+---------------+---------+-------+------+-----------------------+
|  1 | SIMPLE      | DAO_OBJECTS1 | ref_or_null | IDX2_OBJECTS2 | IDX2_OBJECTS2 | 131     | const |    3 | Using index condition |
+----+-------------+--------------+-------------+---------------+---------------+---------+-------+------+-----------------------+
```



### index_merge

```sql
当谓词分别用到多个索引的首列,并且谓词连接为或时
EXPLAIN  SELECT *    FROM DAO_OBJECTS1   WHERE OBJECT_NAME ='DBA_TABLES' OR OBJECT_ID='9527';
+----+-------------+--------------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+
| id | select_type | table        | type        | possible_keys         | key                   | key_len | ref  | rows | Extra                                           |
+----+-------------+--------------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+
|  1 | SIMPLE      | DAO_OBJECTS1 | index_merge | PRIMARY,IDX2_OBJECTS2 | IDX2_OBJECTS2,PRIMARY | 131,4   | NULL |    3 | Using union(IDX2_OBJECTS2,PRIMARY); Using where |
+----+-------------+--------------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+
```



### range

```sql
索引 范围查询 主要出现在><  between in like等
注释：Extra中出现using index表示没有回表  其他的都有回表

explain SELECT * FROM DAO_OBJECTS1 WHERE OBJECT_ID BETWEEN 2000 AND 4000 ;
+----+-------------+--------------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table        | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+--------------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | DAO_OBJECTS1 | range | PRIMARY       | PRIMARY | 4       | NULL | 4012 | Using where |
+----+-------------+--------------+-------+---------------+---------+---------+------+------+-------------+


注意：
--const和range的区别案例；
mysql> flush status;
Query OK, 0 rows affected (0.00 sec)

mysql> desc select * from employees e where e.emp_no=10001;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | e     | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> select * from employees e where e.emp_no=10001;
+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  |
+--------+------------+------------+-----------+--------+------------+
|  10001 | 1953-09-02 | Georgi     | Facello   | M      | 1986-06-26 |
+--------+------------+------------+-----------+--------+------------+
1 row in set (0.00 sec)

mysql> show status like '%handle%';
+---------------------------------------+-------+
| Variable_name                         | Value |
+---------------------------------------+-------+
| Handler_commit                        | 2     |
| Handler_delete                        | 0     |
| Handler_discover                      | 0     |
| Handler_external_lock                 | 4     |
| Handler_mrr_init                      | 0     |
| Handler_prepare                       | 0     |
| Handler_read_first                    | 0     |
| Handler_read_key                      | 2     |
| Handler_read_last                     | 0     |
| Handler_read_next                     | 0     |
| Handler_read_prev                     | 0     |
| Handler_read_rnd                      | 0     |
| Handler_read_rnd_next                 | 0     |
| Handler_rollback                      | 0     |
| Handler_savepoint                     | 0     |
| Handler_savepoint_rollback            | 0     |
| Handler_update                        | 0     |
| Handler_write                         | 0     |
| Performance_schema_file_handles_lost  | 0     |
| Performance_schema_table_handles_lost | 0     |
+---------------------------------------+-------+
20 rows in set (0.00 sec)

mysql> desc select * from employees e where e.emp_no<=10001;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | e     | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.04 sec)

mysql> flush status;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from employees e where e.emp_no<=10001;
+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  |
+--------+------------+------------+-----------+--------+------------+
|  10001 | 1953-09-02 | Georgi     | Facello   | M      | 1986-06-26 |
+--------+------------+------------+-----------+--------+------------+
1 row in set (0.00 sec)

mysql> show status like '%handle%';
+---------------------------------------+-------+
| Variable_name                         | Value |
+---------------------------------------+-------+
| Handler_commit                        | 1     |
| Handler_delete                        | 0     |
| Handler_discover                      | 0     |
| Handler_external_lock                 | 2     |
| Handler_mrr_init                      | 0     |
| Handler_prepare                       | 0     |
| Handler_read_first                    | 1     |
| Handler_read_key                      | 1     |
| Handler_read_last                     | 0     |
| Handler_read_next                     | 1     |
| Handler_read_prev                     | 0     |
| Handler_read_rnd                      | 0     |
| Handler_read_rnd_next                 | 0     |
| Handler_rollback                      | 0     |
| Handler_savepoint                     | 0     |
| Handler_savepoint_rollback            | 0     |
| Handler_update                        | 0     |
| Handler_write                         | 0     |
| Performance_schema_file_handles_lost  | 0     |
| Performance_schema_table_handles_lost | 0     |
+---------------------------------------+-------+
```



### index

```sql
--索引全扫描 比全表排序快,但绝大部分情况下是优化对象
--正常情况下应该在在没有过滤谓词时出现
主要出现在：
不能使用range const ref
只查询索引 不回表,使用索引进行排序或者聚合

例如: 联合索引当中的前导列没在where条件当中，且查询列在索引当中
聚合函数group by后面的列在索引当中 或者 在PK当中，且查询列也在索引当中（速度较快 优化思路）

mysql> EXPLAIN SELECT OBJECT_NAME FROM DAO_OBJECTS1  ORDER BY OBJECT_NAME DESC ;
+----+-------------+--------------+-------+---------------+---------------+---------+------+-------+-------------+
| id | select_type | table        | type  | possible_keys | key           | key_len | ref  | rows  | Extra       |
+----+-------------+--------------+-------+---------------+---------------+---------+------+-------+-------------+
|  1 | SIMPLE      | DAO_OBJECTS1 | index | NULL          | IDX2_OBJECTS2 | 131     | NULL | 52025 | Using index |
+----+-------------+--------------+-------+---------------+---------------+---------+------+-------+-------------+
```



### all

```sql
全表扫描
一般是不好的执行计划，但在大表中查询大量数据的时候，效果很好。

没法使用索引的情况：

1. 单列索引，对索引列进行了加工
2. 对索引进行了隐式转换

mysql> desc select * from test1 where id = '10';
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | test1 | NULL       | ref  | ix_id         | ix_id | 33      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> desc select * from test1 where id = 10;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test1 | NULL       | ALL  | ix_id         | NULL | NULL    | NULL |    2 |    50.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.00 sec)

mysql> show warnings\G;
*************************** 1. row ***************************
  Level: Warning
   Code: 1739
Message: Cannot use ref access on index 'ix_id' due to type or collation conversion on field 'id'
*************************** 2. row ***************************
  Level: Warning
   Code: 1739
Message: Cannot use range access on index 'ix_id' due to type or collation conversion on field 'id'
*************************** 3. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `employees`.`test1`.`id` AS `id`,`employees`.`test1`.`n` AS `n` from `employees`.`test1` where (`employees`.`test1`.`id` = 10)
3 rows in set (0.00 sec)


3.对数字类型列 进行了 like
4.对日期使用了like
```



​      

## possible key

```sql
列出可能使用的索引；

--注意
5.6版本生成的auto_key (临时创建的索引)，消耗一些资源来临时创建
mysql 列超过767个字节无法自动生成auto_key
关注：mysql的convert函数
```



## key

实际使用的索引名称，可以使用 show index from table来查询表中的索引

```SQL
mysql> show index from salaries;
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| salaries |          0 | PRIMARY  |            1 | emp_no      | A         |      292584 |     NULL | NULL   |      | BTREE      |         |               |
| salaries |          0 | PRIMARY  |            2 | from_date   | A         |     2727280 |     NULL | NULL   |      | BTREE      |         |               |
| salaries |          1 | emp_no   |            1 | emp_no      | A         |      289372 |     NULL | NULL   |      | BTREE      |         |               |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
3 rows in set (0.00 sec)

mysql> select count(distinct(emp_no)) from salaries;
+-------------------------+
| count(distinct(emp_no)) |
+-------------------------+
|                  300024 |
+-------------------------+
1 row in set (7.61 sec)

mysql> select count(distinct concat(emp_no,from_date)) from salaries;
+------------------------------------------+
| count(distinct concat(emp_no,from_date)) |
+------------------------------------------+
|                                  2844047 |
+------------------------------------------+
1 row in set (8.95 sec)
```



## key_len

```sql
在复合索引当中看出 索引到底使用了那些列：
从索引列的字节长度来推断：int 类型=4字节   date类型=3字节
key_len 计算公式为:
可变长度*字符集位数+(如果可为null+1 否则+0)+2  声明变长字段


mysql> show create table salaries\G;
*************************** 1. row ***************************
       Table: salaries
Create Table: CREATE TABLE `salaries` (
  `emp_no` int(11) NOT NULL,
  `salary` int(11) NOT NULL,
  `from_date` date NOT NULL,
  `to_date` date NOT NULL,
  PRIMARY KEY (`emp_no`,`from_date`),
  KEY `emp_no` (`emp_no`),
  CONSTRAINT `salaries_ibfk_1` FOREIGN KEY (`emp_no`) REFERENCES `employees` (`emp_no`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)


No query specified

mysql> desc select * from salaries where emp_no='10001' and from_date like '1986%';
+----+-------------+----------+------------+------+----------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys  | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+----------+------------+------+----------------+---------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | salaries | NULL       | ref  | PRIMARY,emp_no | PRIMARY | 4       | const |   17 |    11.11 | Using where |
+----+-------------+----------+------------+------+----------------+---------+---------+-------+------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)

mysql> desc select * from salaries where emp_no='10001' and from_date = '1986-06-26';
+----+-------------+----------+------------+-------+----------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table    | partitions | type  | possible_keys  | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+----------+------------+-------+----------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | salaries | NULL       | const | PRIMARY,emp_no | PRIMARY | 7       | const,const |    1 |   100.00 | NULL  |
+----+-------------+----------+------------+-------+----------------+---------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

### 

## ref

```sql
关联谓词信息或常量:
mysql> EXPLAIN SELECT COUNT(*) FROM DAO_OBJECTS1 T1 ,DAO_OBJECTS2 T2 WHERE T1.OBJECT_ID=T2.OBJECT_ID;
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref              | rows  | Extra       |
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
|  1 | SIMPLE      | T2    | index  | PRIMARY       | PRIMARY | 4       | NULL             | 50887 | Using index |
|  1 | SIMPLE      | T1    | eq_ref | PRIMARY       | PRIMARY | 4       | dao.T2.OBJECT_ID |     1 | Using index |
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
2 rows in set (0.00 sec)


mysql> EXPLAIN SELECT * FROM DAO_OBJECTS1 WHERE OBJECT_NAME = 'DBA_TABLES' ;
+----+-------------+--------------+------+---------------+---------------+---------+-------+------+-----------------------+
| id | select_type | table        | type | possible_keys | key           | key_len | ref   | rows | Extra                 |
+----+-------------+--------------+------+---------------+---------------+---------+-------+------+-----------------------+
|  1 | SIMPLE      | DAO_OBJECTS1 | ref  | IDX2_OBJECTS2 | IDX2_OBJECTS2 | 131     | const |    2 | Using index condition |
+----+-------------+--------------+------+---------------+---------------+---------+-------+------+-----------------------+
1 row in set (0.00 sec)
```



## rows

是mysql 优化器根据统计信息预估出来的值  不准确

```sql
--rows,如果是驱动行源则为该行源大小 如果是被驱动行源,则是单次操作的行源大小
mysql> EXPLAIN SELECT COUNT(*) FROM DAO_OBJECTS1 T1 ,DAO_OBJECTS2 T2 WHERE T1.OBJECT_ID=T2.OBJECT_ID
    -> ;
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref              | rows  | Extra       |
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
|  1 | SIMPLE      | T2    | index  | PRIMARY       | PRIMARY | 4       | NULL             | 50887 | Using index |
|  1 | SIMPLE      | T1    | eq_ref | PRIMARY       | PRIMARY | 4       | dao.T2.OBJECT_ID |     1 | Using index |
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
2 rows in set (0.00 sec)

第一行 row = 50887 为T2表总大小 
第二行 row = 1     代表从T2表取一行 到T1表中遍历可获取的行数的大小 
```



## filtered

预估值，非100%的情况是extra有using where 关键字，表示innodb引擎拿到数据后的再加工的比例。

这个比率也是我们创建索引的良好依据  

如filtered比较小 有必要加入索引当中  （说明该列的选择性很好）

```sql
mysql> desc select count(*) from salaries where emp_no between 10001 and 25000 and salary>1000;
+----+-------------+----------+------------+-------+----------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys  | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+----------+------------+-------+----------------+---------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | salaries | NULL       | range | PRIMARY,emp_no | PRIMARY | 4       | NULL | 285546 |    33.33 | Using where |
+----+-------------+----------+------------+-------+----------------+---------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

```

## EXTRA

```sql
Extra 显示了一些不适合在其他列显示 但是很重要的信息
```

### distinct

1 select 子句当中必须有distinct关键字

2 select 子句当中只能含有驱动表的字段

```sql
mysql> desc select distinct d.emp_no,d.from_date from salaries d join titles de on de.emp_no=d.emp_no and de.from_date=d.from_date;
+----+-------------+-------+------------+--------+----------------+---------+---------+--------------------------------------------+--------+----------+------------------------------+
| id | select_type | table | partitions | type   | possible_keys  | key     | key_len | ref                                        | rows   | filtered | Extra                        |
+----+-------------+-------+------------+--------+----------------+---------+---------+--------------------------------------------+--------+----------+------------------------------+
|  1 | SIMPLE      | de    | NULL       | index  | PRIMARY,emp_no | emp_no  | 4       | NULL                                       | 441832 |   100.00 | Using index; Using temporary |
|  1 | SIMPLE      | d     | NULL       | eq_ref | PRIMARY,emp_no | PRIMARY | 7       | employees.de.emp_no,employees.de.from_date |      1 |   100.00 | Using index                  |
+----+-------------+-------+------------+--------+----------------+---------+---------+--------------------------------------------+--------+----------+------------------------------+
2 rows in set, 1 warning (0.01 sec)
如上所示，执行计划以de为驱动表 所以select子句不含驱动表的字段，不满足条件！
mysql> desc select distinct d.emp_no,d.from_date from salaries d straight_join titles de on de.emp_no=d.emp_no and de.from_date=d.from_date;
+----+-------------+-------+------------+-------+----------------+--------+---------+--------------------+---------+----------+------------------------------------+
| id | select_type | table | partitions | type  | possible_keys  | key    | key_len | ref                | rows    | filtered | Extra                              |
+----+-------------+-------+------------+-------+----------------+--------+---------+--------------------+---------+----------+------------------------------------+
|  1 | SIMPLE      | d     | NULL       | index | PRIMARY,emp_no | emp_no | 4       | NULL               | 2727280 |   100.00 | Using index; Using temporary       |
|  1 | SIMPLE      | de    | NULL       | ref   | PRIMARY,emp_no | emp_no | 4       | employees.d.emp_no |       1 |    10.00 | Using where; Using index; Distinct |
+----+-------------+-------+------------+-------+----------------+--------+---------+--------------------+---------+----------+------------------------------------+
2 rows in set, 1 warning (0.00 sec)
使用straight_join 使得的成为驱动表！
```



### select tables optimized away

select 当中只有min max count的时候出现，不查表的内容，通过统计信息来查询结果。

注意：

where条件在使用复合主键的时候，使用其中任一列，用=连接常量，求出另外一列。并且不包含group by

```sql
mysql> desc select min(emp_no),max(emp_no) from dept_emp where dept_no='d001';
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
1 row in set, 1 warning (0.29 sec)

mysql> desc select min(emp_no),max(emp_no) from dept_emp where dept_no in('d003','d001');
+----+-------------+----------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | dept_emp | NULL       | range | dept_no       | dept_no | 12      | NULL | 71488 |   100.00 | Using where; Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+-------+----------+--------------------------+
1 row in set, 1 warning (0.12 sec)

mysql> desc select min(emp_no),max(emp_no) from dept_emp where dept_no='d001' group by dept_no;
+----+-------------+----------+------------+-------+------------------------+---------+---------+------+------+----------+---------------------------------------+
| id | select_type | table    | partitions | type  | possible_keys          | key     | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+----------+------------+-------+------------------------+---------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | dept_emp | NULL       | range | PRIMARY,emp_no,dept_no | dept_no | 12      | NULL |    1 |   100.00 | Using where; Using index for group-by |
+----+-------------+----------+------------+-------+------------------------+---------+---------+------+------+----------+---------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> desc select min(emp_no),max(emp_no) from dept_emp where dept_no='d001' limit 10;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
1 row in set, 1 warning (0.00 sec)
```



### using filesort

在进行order by  ，group by且没有使用索引

```SQL
mysql> desc select dept_no,count(emp_no) from t_order group by dept_no;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
|  1 | SIMPLE      | t_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |   100.00 | Using temporary; Using filesort |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
1 row in set, 1 warning (0.00 sec)
5.7之前的版本group by默认带排序

结果集如下：
mysql> select dept_no,count(emp_no) from t_order group by dept_no;
+---------+---------------+
| dept_no | count(emp_no) |
+---------+---------------+
| d002    |             1 |
| d004    |             1 |
| d005    |             4 |
| d006    |             1 |
| d007    |             1 |
| d008    |             1 |
+---------+---------------+
6 rows in set (0.06 sec)


mysql> show index from t_group \G;
Empty set (0.00 sec)

```

 

### using index

只是用索引 ，不回表

如果表对应的where条件的选择率不是很好，且行的长度很长，这时候为了速度，可以考虑创建包含对应列的索引，达到减少物理IO的目的

```sql
mysql> EXPLAIN SELECT COUNT(*) FROM DAO_OBJECTS1 T1 ,DAO_OBJECTS2 T2 WHERE T1.OBJECT_ID=T2.OBJECT_ID;
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
| id | select_type | table | type   | possible_keys | key     | key_len | ref              | rows  | Extra       |
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
|  1 | SIMPLE      | T2    | index  | PRIMARY       | PRIMARY | 4       | NULL             | 50887 | Using index |
|  1 | SIMPLE      | T1    | eq_ref | PRIMARY       | PRIMARY | 4       | dao.T2.OBJECT_ID |     1 | Using index |
+----+-------------+-------+--------+---------------+---------+---------+------------------+-------+-------------+
     
```

​        

### using temporary

SQL执行过程中，为了存储中间结果，会使用temporary table

但是，如果执行计划当中出现using temporary ，但是无法判断此中间结果是在内存当中，还是在磁盘当中。

$ order by ,group by 没有使用索引的时候

$  执行计划当中 select type为derived

```mssql
mysql> show session status like '%tmp%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 0     |
| Created_tmp_files       | 6     |
| Created_tmp_tables      | 8     |
+-------------------------+-------+
3 rows in set (0.00 sec)

注：查看初始临时表

mysql> desc select count(*) from (select * from employees limit 100) s;
+----+-------------+------------+------------+------+---------------+------+---------+------+--------+----------+-------+
| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra |
+----+-------------+------------+------------+------+---------------+------+---------+------+--------+----------+-------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    100 |   100.00 | NULL  |
|  2 | DERIVED     | employees  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299202 |   100.00 | NULL  |
+----+-------------+------------+------------+------+---------------+------+---------+------+--------+----------+-------+
2 rows in set, 1 warning (0.00 sec)

mysql> select count(*) from (select * from employees limit 100) s;
+----------+
| count(*) |
+----------+
|      100 |
+----------+
1 row in set (0.00 sec)
注：运行SQL，查看执行计划，使用临时表

mysql> show session status like '%tmp%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 0     |
| Created_tmp_files       | 6     |
| Created_tmp_tables      | 10    |
+-------------------------+-------+
3 rows in set (0.01 sec)

注： 运行SQL后，查看临时表的情况 
$ 两个重要参数：  临时表的大小相关  ；超过此参数大小，使用磁盘
mysql> show variables like '%table%size%';
+---------------------+----------+
| Variable_name       | Value    |
+---------------------+----------+
| max_heap_table_size | 16777216 |
| tmp_table_size      | 16777216 |
+---------------------+----------+
```



### using where

  一般和filtered  rows一起看；表示从存储引擎当中拿到数据，再在mysql服务层过滤数据；

### using index condition

```mssql
一般只有二级索引才有

set session optimizer_switch="index_condition_pushdown=on"    打开ICP特性，默认是开启的。

如果WHERE条件可以使用索引，MySQL 会把这部分过滤操作放到存储引擎层，存储引擎通过索引过滤，把满足的行从表中读取出。ICP能减少Server层访问存储引擎的次数和引擎层访问基表的次数。

注意：只有是在二级索引当中 ，而且where条件当中有部分无法使用索引，ICP才起作用！

mysql> show index from salaries;
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| salaries |          0 | PRIMARY  |            1 | emp_no      | A         |      292584 |     NULL | NULL   |      | BTREE      |         |               |
| salaries |          0 | PRIMARY  |            2 | from_date   | A         |     2727280 |     NULL | NULL   |      | BTREE      |         |               |
| salaries |          1 | emp_no   |            1 | emp_no      | A         |      289372 |     NULL | NULL   |      | BTREE      |         |               |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
3 rows in set (0.00 sec)

mysql> desc select sum(salary) from salaries force index(emp_no) where emp_no between 10010 and 200000 and from_date like '1985%'
    -> ;
+----+-------------+----------+------------+-------+---------------+--------+---------+------+---------+----------+-----------------------+
| id | select_type | table    | partitions | type  | possible_keys | key    | key_len | ref  | rows    | filtered | Extra                 |
+----+-------------+----------+------------+-------+---------------+--------+---------+------+---------+----------+-----------------------+
|  1 | SIMPLE      | salaries | NULL       | range | emp_no        | emp_no | 4       | NULL | 1363640 |    11.11 | Using index condition |
+----+-------------+----------+------------+-------+---------------+--------+---------+------+---------+----------+-----------------------+
1 row in set, 2 warnings (0.29 sec)

关闭此参数，再来查看执行计划
mysql> set session optimizer_switch="index_condition_pushdown=off" ;
Query OK, 0 rows affected (0.00 sec)

mysql> desc select sum(salary) from salaries force index(emp_no) where emp_no between 10010 and 200000 and from_date like '1985%';
+----+-------------+----------+------------+-------+---------------+--------+---------+------+---------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key    | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+--------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | salaries | NULL       | range | emp_no        | emp_no | 4       | NULL | 1363640 |    11.11 | Using where |
+----+-------------+----------+------------+-------+---------------+--------+---------+------+---------+----------+-------------+
1 row in set, 2 warnings (0.00 sec)

mysql> select sum(salary) from salaries force index(emp_no) where emp_no between 10010 and 200000 and from_date like '1985%';
+-------------+
| sum(salary) |
+-------------+
|   323909218 |
+-------------+
1 row in set, 1 warning (2.65 sec)

mysql> set session optimizer_switch="index_condition_pushdown=on" ;
Query OK, 0 rows affected (0.00 sec)

mysql> select sum(salary) from salaries force index(emp_no) where emp_no between 10010 and 200000 and from_date like '1985%';
+-------------+
| sum(salary) |
+-------------+
|   323909218 |
+-------------+
1 row in set, 1 warning (0.14 sec)

```

  

​         

### using MRR

```SQL
set session optimizer_switch='mrr=on,mrr_cost_based=off';

随机 IO 转化为顺序 IO 以降低查询过程中 IO 开销的一种手段，这对IO-bound类型的SQL语句性能带来极大的提升。

而MRR的优化在于，并不是每次通过辅助索引就回表去取记录，而是将其rowid给缓存起来，然后对rowid进行排序后，再去访问记录，这样就能将随机I/O转化为顺序I/O，从而大幅地提升性能。 

**然而，在MySQL当前版本中，基于成本的算法过于保守，导致大部分情况下优化器都不会选择MRR特性**。
参数read_rnd_buffer_size决定主键中间排序的空间大小！


实验：
mysql> desc select * from t_group2 force index(ix_dept_no2) where dept_no>'';
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
| id | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t_group2 | NULL       | range | ix_dept_no2   | ix_dept_no2 | 12      | NULL |   10 |   100.00 | Using index condition |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.33 sec)

打开MRR参数，查看执行计划
mysql> set session optimizer_switch='mrr_cost_based=off';
Query OK, 0 rows affected (0.00 sec)

mysql> desc select * from t_group2 force index(ix_dept_no2) where dept_no>'';
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra                            |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------+
|  1 | SIMPLE      | t_group2 | NULL       | range | ix_dept_no2   | ix_dept_no2 | 12      | NULL |   10 |   100.00 | Using index condition; Using MRR |
+----+-------------+----------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql> select * from t_group2 force index(ix_dept_no2) where dept_no>'';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)
--可以看到，在5.7版本当中，显示的索引列的顺序被打乱，因为中间结果的主键是按照顺序排列的！

mysql> set session optimizer_switch='mrr_cost_based=on';
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t_group2 force index(ix_dept_no2) where dept_no>'';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  31112 | d002    | 1986-12-01 | 1993-12-10 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  24007 | d005    | 1986-12-01 | 9999-01-01 |
|  30970 | d005    | 1986-12-01 | 2017-03-29 |
|  40983 | d005    | 1986-12-01 | 9999-01-01 |
|  50449 | d005    | 1986-12-01 | 9999-01-01 |
|  22744 | d006    | 1986-12-01 | 9999-01-01 |
|  49667 | d007    | 1986-12-01 | 9999-01-01 |
|  46554 | d008    | 1986-12-01 | 1992-05-27 |
|  48317 | d008    | 1986-12-01 | 1989-01-11 |
+--------+---------+------------+------------+
10 rows in set (0.00 sec)
--不使用MRR特性，索引列按照顺序排列！
```

 

### range checked for each record

```SQL
出现的时候，表示优化对象出现。TYPE肯定是ALL，意思是：索引检测每一行是否使用索引！（引发的原因有索引列发生隐式转换）

处理办法：
^  查看执行计划
^  紧接着执行show warnings 
```

​          

### using join buffer（Block Nested Loop）

```SQL
两个相关参数：
set session optimizer_switch="block_nested_loop=on,batched_key_access=on"

主要在被驱动表没有索引且数据量较少（比如数据量只占一个数据页）的情况下，有作用，执行速度比索引要快！因为索引至少是两层结构！
大部分情况是优化对象！

--获取运行中SQL执行计划的方法
show processlist；获取connection id
desc for connection 2;查看执行计划
```



## 执行计划案例

Eg：1           

```sql
mysql> desc select t1.emp_no from t1 join (select distinct a.emp_no from (select e.emp_no from employees e where e.emp_no between 10001 and 11000 limit 1000) a) E1 on t1.emp_no=E1.emp_no limit 5;
+----+-------------+------------+------------+-------+----------------+---------+---------+-----------+------+----------+--------------------------+
| id | select_type | table      | partitions | type  | possible_keys  | key     | key_len | ref       | rows | filtered | Extra                    |
+----+-------------+------------+------------+-------+----------------+---------+---------+-----------+------+----------+--------------------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL           | NULL    | NULL    | NULL      | 1000 |   100.00 | NULL                     |
|  1 | PRIMARY     | t1         | NULL       | ref   | PRIMARY,emp_no | emp_no  | 4       | E1.emp_no |    9 |   100.00 | Using index              |
|  2 | DERIVED     | <derived3> | NULL       | ALL   | NULL           | NULL    | NULL    | NULL      | 1000 |   100.00 | Using temporary          |
|  3 | DERIVED     | e          | NULL       | range | PRIMARY        | PRIMARY | 4       | NULL      | 1000 |   100.00 | Using where; Using index |
+----+-------------+------------+------------+-------+----------------+---------+---------+-----------+------+----------+--------------------------+
4 rows in set, 1 warning (0.12 sec)
e表是执行计划当中的驱动表
```



Eg: 2

```sql
MySql 解析器出错，执行结果不出【通常是优化器里面的参数 materialized  和 semijoin 导致的】

分析SQL的基本套路：
1 打开执行计划，show warnings  （能出结果的子查询和不能出结果的SQL）
2 比较执行计划
```



Eg: 3

```powershell
针对mysql不支持索引跳跃式扫描的优化

select date_format(CreateTime ,'%Y-%m-%d') as createtime,count(*) as count from T_sinaCard where userid <> 10000 and createtime >='2018-09-21' group by date(CreateTime);

解释：表结构当中createtime 和  state是联合索引；由于mysql不支持跳跃扫描，前导列不在where条件当中，导致索引无法使用，全表扫描。
思路是把前导列加入索引当中：
select distinct(state) from T_sinacard ; 发现state只有0-6 的7中状态；

所以改写SQL为：
select date_format(CreateTime ,'%Y-%m-%d') as createtime,count(*) as count from T_sinaCard where userid <> 10000 and state in (0,1,2,3,4,5,6) and createtime >='2018-09-21' group by date(CreateTime);

执行计划使用联合索引！
```



